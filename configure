#! /usr/bin/env tclsh
# tcl-augeas, Tcl bindings for Augeas.
# Copyright (C) 2015, 2016, 2017 dbohdan.
# This code is released under the terms of the MIT license. See the file
# LICENSE for details.
namespace eval ::buildsys {
    namespace export *
    namespace ensemble create

    variable path
    variable cc cc
    variable packages [list augeas]
    variable flags [list -Wall -fPIC]
    variable includes [list -I[::tcl::pkgconfig get includedir,runtime]]
    variable libs [list -L[::tcl::pkgconfig get libdir,runtime]]
    variable tclsh [info nameofexecutable]

    variable input tcl-augeas.c
    variable object libtclaugeas.o
    variable output libtclaugeas[info sharedlibextension]
    variable extras [list augeas::oo oo.tcl]

    variable packageInstallPath [file join \
            [::tcl::pkgconfig get scriptdir,runtime] tcl-augeas]
    variable libInstallPath [::tcl::pkgconfig get libdir,runtime]

    variable makefile {}
}

# Generate and return the contents of a makefile for tcl-augeas.
proc ::buildsys::generate-makefile {libInstallPath packageInstallPath} {
    variable libraryFilename
    variable makefile
    variable output
    variable tclsh

    set makefile {}

    target all test
    target $output tcl-augeas.c
    build
    target clean
    clean
    target deps
    deps
    target test $output
    test
    target install $output
    install $libInstallPath $packageInstallPath
    target uninstall
    uninstall $libInstallPath $packageInstallPath
    target .PHONY {all clean deps test install uninstall}
    return $makefile
}

# Add the target $name with dependencies $deps to the current makefile.
proc ::buildsys::target {name {deps {}}} {
    variable makefile
    append makefile "$name: [join $deps]\n"
}

# Quote $s for the makefile.
proc ::buildsys::quote s {
    if {[regexp {[^a-zA-Z0-9_./-]} $s]} {
        # Quote $arg and escape any single quotes in it.
        return '[string map {' '"'"' $ $$} $s]'
    } else {
        return $s
    }
}

# Quote $strings.
proc ::buildsys::quote-all args {
    set result {}
    foreach s $args {
        lappend result [quote $s]
    }
    return [join $result]
}

# Add a command to the current makefile target quoting each of the arguments.
proc ::buildsys::command args {
    variable makefile
    command-raw {*}[quote-all {*}$args]
}

# Add a command to the current makefile target without quoting.
proc ::buildsys::command-raw args {
    variable makefile
    append makefile \t[join $args]\n
}

# Emit the commands to build the extension.
proc ::buildsys::build {} {
    variable cc
    variable packages
    variable flags
    variable includes
    variable libs
    variable input
    variable object
    variable output
    variable path

    foreach package $packages {
        lappend includes {*}[exec -- pkg-config --cflags $package]
        lappend libs {*}[exec -- pkg-config --libs $package]
    }

    set augeasVersion [exec -- pkg-config --modversion augeas]
    if {[package vcompare $augeasVersion {1.0.0}] == -1} {
        lappend flags -DNO_AUG_RENAME
    }

    # Retry in case the default build fails.
    command $cc {*}$flags -c -o $object $input {*}$includes
    command $cc {*}$flags -o $output $object -shared {*}$libs
}

# Return the user's OS.
proc ::buildsys::detect-os {} {
    set uname [exec -- uname]
    if {$uname eq "Linux"} {
        if {[file exists /etc/debian_version]} {
            return debian
        } elseif {[file exists /etc/redhat-release]} {
            return redhat
        } elseif {![catch {exec -- grep -q openSUSE /etc/os-release}]} {
            return opensuse
        } else {
            return unknown-linux
        }
    } elseif {$uname eq "FreeBSD"} {
        return freebsd
    } elseif {$uname eq "OpenBSD"} {
        return openbsd
    } elseif {$uname eq "NetBSD"} {
        return netbsd
    } else {
        return unknown
    }
}

# Emit the command to install the dependencies needed to build the extension.
# The command should be run as root.
proc ::buildsys::deps {} {
    set commands {
        redhat
        {{yum install -y gcc make pkgconfig tcl-devel augeas-devel}}

        debian
        {{apt-get install -y build-essential pkg-config tcl-dev libaugeas-dev}}

        opensuse
        {{zypper install -y gcc make pkgconfig tcl-devel augeas-devel}}

        freebsd
        {{pkg install augeas pkgconf}}

        openbsd
        {{pkg_add augeas}}
    }

    set os [detect-os]
    if {[dict exists $commands $os]} {
        foreach command [dict get $commands $os] {
            command {*}$command
        }
    } else {
        command-raw @echo [quote {Sorry, automatic dependency installation is\
                not supported on your OS. Please install the dependencies\
                manually.}]
        command-raw @false
    }
}

# Emit the commands to clean up the build artifacts.
proc ::buildsys::clean {} {
    variable object
    variable output
    command -rm $object
    command -rm $output
}

# Emit the command to run the test suite.
proc ::buildsys::test {} {
    variable path
    variable tclsh
    command $tclsh [file join $path tests.tcl]
}

# Emit the command to copy file $from to $to.
proc ::buildsys::copy {from to} {
    command cp $from $to
}

# Emit the command to delete file or directory $path.
proc ::buildsys::delete path {
    command -rm $path
}

# Emit the command to write the text $content to $filename. This is crude and
# may not work for arbitrary text.
proc ::buildsys::write-file {filename content} {
    command-raw echo [string map [list \n \\n] [quote $content]] \
            | sed [quote {s/\\n/\n/g}] > [quote $filename]
}

# Emit the commands to install the extension library and the corresponding Tcl
# package.
proc ::buildsys::install {libInstallPath packageInstallPath} {
    variable extras
    variable output
    variable path

    command mkdir -p $packageInstallPath
    copy [file join $path $output] $libInstallPath

    # Copy extra files.
    foreach {package filename} $extras {
        copy [file join $path $filename] $packageInstallPath
    }

    variable input
    variable output

    # Get package name and version from $input.
    foreach {varName awkScript} {
        mainPackageName {/#define PACKAGE/ { print $3 }}
        version {/#define VERSION/ { print $3 }}
    } {
        variable $varName [string trim \
                [exec -- awk $awkScript [file join $path $input]] \"]
    }

    # Create pkgIndex.tcl.
    set content [list apply {
        {mainPackageName version libInstallPath sharedLibrary packageInstallPath
                extras} {
            package ifneeded $mainPackageName $version \
                    [list load [file join $libInstallPath $sharedLibrary]]
            foreach {extraPackageName filename} $extras {
                package ifneeded $extraPackageName $version \
                        [list source [file join $packageInstallPath $filename]]
            }
        }
    } $mainPackageName $version $libInstallPath $output $packageInstallPath\
            $extras]
    write-file [file join $packageInstallPath pkgIndex.tcl] $content
}

# Emit the commands to remove the extension library and the corresponding Tcl
# package.
proc ::buildsys::uninstall {libInstallPath packageInstallPath} {
    variable extras
    variable output

    delete [file join $libInstallPath $output]
    delete [file join $packageInstallPath pkgIndex.tcl]
    foreach {package filename} $extras {
        delete [file join $packageInstallPath $filename]
    }
    command rmdir [file join $packageInstallPath]
}

# Check if we were run as the primary script by the interpreter. Code from
# https://wiki.tcl-lang.org/40097.
proc ::buildsys::main-script? {} {
    global argv0

    if {[info exists argv0] &&
            [file exists [info script]] &&
            [file exists $argv0]} {
        file stat $argv0 argv0Info
        file stat [info script] scriptInfo
        expr {$argv0Info(dev) == $scriptInfo(dev)
           && $argv0Info(ino) == $scriptInfo(ino)}
    } else {
        return 0
    }
}

# Parse the command line.
proc ::buildsys::parse-options {argv0 argv} {
    set usage "Usage: $argv0 \[--destdir PATH\]"

    if {([lsearch $argv {-h}] != -1) || ([lsearch $argv {--help}] != -1)} {
        puts $usage
        exit 0
    }
    if {[llength $argv] % 2 == 1} {
        puts "Error: Can't parse the command line arguments (\"$argv\").\
                Expected an even number of them (a Tcl dictionary)."
        exit 1
    }

    set destdir {}
    if {[dict exists $argv --destdir]} {
        set destdir [dict get $argv --destdir]
        dict unset argv --destdir
    }

    if {[dict size $argv] > 0} {
        set unknownOpts {}
        foreach {k v} $argv {
            lappend unknownOpts "\"$k $v\""
        }
        puts "Unknown option(s): [join $unknownOpts {, }]."
        exit 1
    }

    return $destdir
}

proc ::buildsys::main {argv0 argv} {
    set ::buildsys::path \
            [file dirname [file dirname [file normalize $argv0/___]]]

    set destdir [parse-options $argv0 $argv]
    if {$destdir ne {}} {
        set libInstallPath $destdir
        set packageInstallPath $destdir
    } else {
        variable libInstallPath
        variable packageInstallPath
    }

    puts "[file tail [info script]]: creating Makefile"
    set makefile [buildsys generate-makefile \
            $libInstallPath $packageInstallPath]
    set ch [open Makefile w]
    puts -nonewline $ch $makefile
    close $ch
}

if {[::buildsys::main-script?]} {
    ::buildsys::main $argv0 $argv
}
